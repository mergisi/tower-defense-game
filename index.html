<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crystal Siege ‚Äî Tower Defense</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg-dark: #0a0e17;
    --bg-panel: #111827;
    --accent-cyan: #00f0ff;
    --accent-magenta: #ff2d7b;
    --accent-gold: #ffd700;
    --accent-green: #00ff88;
    --text-primary: #e8edf5;
    --text-muted: #6b7a96;
    --grid-line: rgba(0, 240, 255, 0.06);
    --tower-archer: #00ccff;
    --tower-cannon: #ff6b35;
    --tower-frost: #8bdfff;
    --tower-laser: #ff2d7b;
  }

  body {
    background: var(--bg-dark);
    color: var(--text-primary);
    font-family: 'Rajdhani', sans-serif;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
    user-select: none;
  }

  /* ‚îÄ‚îÄ‚îÄ Top Bar ‚îÄ‚îÄ‚îÄ */
  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 24px;
    background: linear-gradient(180deg, rgba(17,24,39,0.98), rgba(17,24,39,0.85));
    border-bottom: 1px solid rgba(0,240,255,0.1);
    z-index: 10;
    flex-shrink: 0;
  }

  .game-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: 900;
    letter-spacing: 3px;
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-transform: uppercase;
  }

  .stats-bar {
    display: flex;
    gap: 28px;
    align-items: center;
  }

  .stat {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 15px;
    font-weight: 600;
  }

  .stat-icon {
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
  }

  .stat-value {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: 700;
  }

  .stat-value.gold { color: var(--accent-gold); }
  .stat-value.lives { color: var(--accent-magenta); }
  .stat-value.wave { color: var(--accent-cyan); }
  .stat-value.score { color: var(--accent-green); }

  .game-controls {
    display: flex;
    gap: 10px;
  }

  .btn {
    font-family: 'Rajdhani', sans-serif;
    font-weight: 700;
    font-size: 13px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    padding: 8px 18px;
    border: 1px solid;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    background: transparent;
  }

  .btn-start {
    border-color: var(--accent-green);
    color: var(--accent-green);
  }
  .btn-start:hover {
    background: var(--accent-green);
    color: var(--bg-dark);
    box-shadow: 0 0 20px rgba(0,255,136,0.3);
  }

  .btn-speed {
    border-color: var(--accent-cyan);
    color: var(--accent-cyan);
  }
  .btn-speed:hover, .btn-speed.active {
    background: var(--accent-cyan);
    color: var(--bg-dark);
  }

  .btn-restart {
    border-color: var(--accent-magenta);
    color: var(--accent-magenta);
  }
  .btn-restart:hover {
    background: var(--accent-magenta);
    color: var(--bg-dark);
  }

  /* ‚îÄ‚îÄ‚îÄ Main Area ‚îÄ‚îÄ‚îÄ */
  .main-area {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  /* ‚îÄ‚îÄ‚îÄ Canvas ‚îÄ‚îÄ‚îÄ */
  .game-canvas-wrapper {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  #gameCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  /* ‚îÄ‚îÄ‚îÄ Side Panel ‚îÄ‚îÄ‚îÄ */
  .side-panel {
    width: 220px;
    background: var(--bg-panel);
    border-left: 1px solid rgba(0,240,255,0.08);
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex-shrink: 0;
    overflow-y: auto;
  }

  .panel-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 4px;
  }

  .tower-card {
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 8px;
    padding: 12px;
    cursor: pointer;
    transition: all 0.25s;
    position: relative;
  }

  .tower-card:hover {
    border-color: rgba(0,240,255,0.3);
    background: rgba(0,240,255,0.04);
    transform: translateY(-1px);
  }

  .tower-card.selected {
    border-color: var(--accent-cyan);
    background: rgba(0,240,255,0.08);
    box-shadow: 0 0 16px rgba(0,240,255,0.15);
  }

  .tower-card.disabled {
    opacity: 0.35;
    pointer-events: none;
  }

  .tower-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 6px;
  }

  .tower-card-icon {
    width: 36px;
    height: 36px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 900;
    flex-shrink: 0;
  }

  .tower-card-info {
    flex: 1;
  }

  .tower-card-name {
    font-weight: 700;
    font-size: 14px;
    line-height: 1.1;
  }

  .tower-card-cost {
    font-size: 12px;
    color: var(--accent-gold);
    font-weight: 600;
  }

  .tower-card-desc {
    font-size: 11px;
    color: var(--text-muted);
    line-height: 1.3;
  }

  .tower-card-stats {
    display: flex;
    gap: 12px;
    margin-top: 6px;
    font-size: 10px;
    color: var(--text-muted);
  }

  .hotkey {
    position: absolute;
    top: 6px;
    right: 8px;
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: var(--text-muted);
    background: rgba(255,255,255,0.05);
    padding: 2px 6px;
    border-radius: 3px;
  }

  /* ‚îÄ‚îÄ‚îÄ Wave Banner ‚îÄ‚îÄ‚îÄ */
  .wave-banner {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-family: 'Orbitron', sans-serif;
    font-size: 48px;
    font-weight: 900;
    color: var(--accent-cyan);
    text-shadow: 0 0 40px rgba(0,240,255,0.5), 0 0 80px rgba(0,240,255,0.2);
    pointer-events: none;
    z-index: 100;
    opacity: 0;
    transition: all 0.5s cubic-bezier(0.22, 1, 0.36, 1);
  }

  .wave-banner.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  /* ‚îÄ‚îÄ‚îÄ Game Over Overlay ‚îÄ‚îÄ‚îÄ */
  .game-over-overlay {
    position: fixed;
    inset: 0;
    background: rgba(10,14,23,0.92);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 200;
    flex-direction: column;
    gap: 20px;
    backdrop-filter: blur(8px);
  }

  .game-over-overlay.show {
    display: flex;
  }

  .game-over-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 56px;
    font-weight: 900;
    background: linear-gradient(135deg, var(--accent-magenta), var(--accent-gold));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .game-over-score {
    font-family: 'Orbitron', sans-serif;
    font-size: 22px;
    color: var(--text-muted);
  }

  .game-over-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: 700;
    padding: 14px 40px;
    background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
    border: none;
    border-radius: 6px;
    color: white;
    cursor: pointer;
    letter-spacing: 2px;
    text-transform: uppercase;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .game-over-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(0,240,255,0.3);
  }

  /* ‚îÄ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ‚îÄ */
  .tower-tooltip {
    position: fixed;
    background: rgba(17,24,39,0.95);
    border: 1px solid rgba(0,240,255,0.2);
    border-radius: 8px;
    padding: 12px;
    font-size: 12px;
    pointer-events: none;
    z-index: 150;
    display: none;
    width: 180px;
    backdrop-filter: blur(8px);
  }

  .tower-tooltip .tt-name {
    font-weight: 700;
    font-size: 14px;
    margin-bottom: 4px;
  }

  .tower-tooltip .tt-stats {
    color: var(--text-muted);
    line-height: 1.5;
  }

  .tower-tooltip .tt-upgrade {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid rgba(255,255,255,0.1);
    color: var(--accent-gold);
    font-weight: 600;
  }

  /* Scrollbar */
  .side-panel::-webkit-scrollbar { width: 4px; }
  .side-panel::-webkit-scrollbar-track { background: transparent; }
  .side-panel::-webkit-scrollbar-thumb { background: rgba(0,240,255,0.15); border-radius: 4px; }
</style>
</head>
<body>

<div class="top-bar">
  <div class="game-title">Crystal Siege</div>
  <div class="stats-bar">
    <div class="stat">
      <div class="stat-icon">üí∞</div>
      <div class="stat-value gold" id="goldValue">200</div>
    </div>
    <div class="stat">
      <div class="stat-icon">‚ù§Ô∏è</div>
      <div class="stat-value lives" id="livesValue">20</div>
    </div>
    <div class="stat">
      <div class="stat-icon">üåä</div>
      <div class="stat-value wave" id="waveValue">0 / 0</div>
    </div>
    <div class="stat">
      <div class="stat-icon">‚≠ê</div>
      <div class="stat-value score" id="scoreValue">0</div>
    </div>
  </div>
  <div class="game-controls">
    <button class="btn btn-start" id="btnStart" onclick="startWave()">Send Wave</button>
    <button class="btn btn-speed" id="btnSpeed" onclick="toggleSpeed()">2√ó</button>
    <button class="btn btn-restart" onclick="restartGame()">Reset</button>
  </div>
</div>

<div class="main-area">
  <div class="game-canvas-wrapper">
    <canvas id="gameCanvas"></canvas>
  </div>
  <div class="side-panel">
    <div class="panel-title">Towers</div>
    <div class="tower-card" data-tower="archer" onclick="selectTower('archer')">
      <div class="hotkey">1</div>
      <div class="tower-card-header">
        <div class="tower-card-icon" style="background:rgba(0,204,255,0.15);color:var(--tower-archer);">üèπ</div>
        <div class="tower-card-info">
          <div class="tower-card-name">Bolt Tower</div>
          <div class="tower-card-cost">üí∞ 50</div>
        </div>
      </div>
      <div class="tower-card-desc">Fast attacks, single target</div>
      <div class="tower-card-stats"><span>DMG: 15</span><span>SPD: Fast</span><span>RNG: Med</span></div>
    </div>

    <div class="tower-card" data-tower="cannon" onclick="selectTower('cannon')">
      <div class="hotkey">2</div>
      <div class="tower-card-header">
        <div class="tower-card-icon" style="background:rgba(255,107,53,0.15);color:var(--tower-cannon);">üí£</div>
        <div class="tower-card-info">
          <div class="tower-card-name">Blast Tower</div>
          <div class="tower-card-cost">üí∞ 100</div>
        </div>
      </div>
      <div class="tower-card-desc">Splash damage, slow fire</div>
      <div class="tower-card-stats"><span>DMG: 40</span><span>SPD: Slow</span><span>AOE: Yes</span></div>
    </div>

    <div class="tower-card" data-tower="frost" onclick="selectTower('frost')">
      <div class="hotkey">3</div>
      <div class="tower-card-header">
        <div class="tower-card-icon" style="background:rgba(139,223,255,0.15);color:var(--tower-frost);">‚ùÑÔ∏è</div>
        <div class="tower-card-info">
          <div class="tower-card-name">Frost Tower</div>
          <div class="tower-card-cost">üí∞ 75</div>
        </div>
      </div>
      <div class="tower-card-desc">Slows enemies in range</div>
      <div class="tower-card-stats"><span>DMG: 8</span><span>SLOW: 50%</span><span>RNG: Med</span></div>
    </div>

    <div class="tower-card" data-tower="laser" onclick="selectTower('laser')">
      <div class="hotkey">4</div>
      <div class="tower-card-header">
        <div class="tower-card-icon" style="background:rgba(255,45,123,0.15);color:var(--tower-laser);">‚ö°</div>
        <div class="tower-card-info">
          <div class="tower-card-name">Beam Tower</div>
          <div class="tower-card-cost">üí∞ 150</div>
        </div>
      </div>
      <div class="tower-card-desc">Continuous beam, high DPS</div>
      <div class="tower-card-stats"><span>DPS: 35</span><span>SPD: Cont.</span><span>RNG: Long</span></div>
    </div>

    <div class="panel-title" style="margin-top: 12px;">Actions</div>
    <div class="tower-card" onclick="enterSellMode()" id="sellCard">
      <div class="hotkey">S</div>
      <div class="tower-card-header">
        <div class="tower-card-icon" style="background:rgba(255,215,0,0.12);color:var(--accent-gold);">ü™ô</div>
        <div class="tower-card-info">
          <div class="tower-card-name">Sell Tower</div>
          <div class="tower-card-desc">Click a tower to sell (60%)</div>
        </div>
      </div>
    </div>

    <div class="panel-title" style="margin-top: 12px;">Info</div>
    <div style="font-size:11px;color:var(--text-muted);line-height:1.5;">
      Click on the map to place towers. Towers can only be placed on grass (not on the path). Right-click or press ESC to cancel. Click a placed tower to upgrade it.
    </div>
  </div>
</div>

<div class="wave-banner" id="waveBanner"></div>
<div class="game-over-overlay" id="gameOverOverlay">
  <div class="game-over-title" id="gameOverTitle">Game Over</div>
  <div class="game-over-score" id="gameOverScore"></div>
  <button class="game-over-btn" onclick="restartGame()">Play Again</button>
</div>
<div class="tower-tooltip" id="towerTooltip">
  <div class="tt-name"></div>
  <div class="tt-stats"></div>
  <div class="tt-upgrade"></div>
</div>

<script>
// ‚îÄ‚îÄ‚îÄ GAME CONSTANTS ‚îÄ‚îÄ‚îÄ
const CELL = 40;
let COLS, ROWS;
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ‚îÄ‚îÄ‚îÄ PATH DEFINITION (grid coords) ‚îÄ‚îÄ‚îÄ
let pathPoints = [];

function buildPath() {
  // S-shaped path across the map
  const pts = [];
  const midY = Math.floor(ROWS / 2);
  const topY = Math.max(2, Math.floor(ROWS * 0.2));
  const botY = Math.min(ROWS - 3, Math.floor(ROWS * 0.8));

  // Enter from left
  for (let x = 0; x <= Math.floor(COLS * 0.25); x++) pts.push([x, midY]);
  // Go up
  for (let y = midY - 1; y >= topY; y--) pts.push([Math.floor(COLS * 0.25), y]);
  // Go right
  for (let x = Math.floor(COLS * 0.25) + 1; x <= Math.floor(COLS * 0.55); x++) pts.push([x, topY]);
  // Go down
  for (let y = topY + 1; y <= botY; y++) pts.push([Math.floor(COLS * 0.55), y]);
  // Go left a bit
  for (let x = Math.floor(COLS * 0.55) - 1; x >= Math.floor(COLS * 0.4); x--) pts.push([x, botY]);
  // Go up to mid
  for (let y = botY - 1; y >= midY; y--) pts.push([Math.floor(COLS * 0.4), y]);
  // Go right to exit
  for (let x = Math.floor(COLS * 0.4) + 1; x <= COLS; x++) pts.push([x, midY]);

  return pts;
}

let pathSet = new Set();

function rebuildPathSet() {
  pathSet.clear();
  pathPoints.forEach(([x, y]) => pathSet.add(`${x},${y}`));
}

// ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ
let gold = 200;
let lives = 20;
let score = 0;
let wave = 0;
const totalWaves = 25;
let waveActive = false;
let gameOver = false;
let speedMultiplier = 1;
let selectedTowerType = null;
let sellMode = false;
let towers = [];
let enemies = [];
let projectiles = [];
let particles = [];
let hoveredTower = null;

// ‚îÄ‚îÄ‚îÄ TOWER DEFINITIONS ‚îÄ‚îÄ‚îÄ
const TOWER_DEFS = {
  archer: {
    name: 'Bolt Tower', cost: 50, damage: 15, range: 3.2, fireRate: 0.5,
    color: '#00ccff', icon: 'üèπ', splash: 0, slow: 0,
    upgrades: [
      { cost: 40, damage: 22, range: 3.5, fireRate: 0.4 },
      { cost: 80, damage: 35, range: 4, fireRate: 0.3 },
    ]
  },
  cannon: {
    name: 'Blast Tower', cost: 100, damage: 40, range: 2.8, fireRate: 1.5,
    color: '#ff6b35', icon: 'üí£', splash: 1.2, slow: 0,
    upgrades: [
      { cost: 75, damage: 65, range: 3, fireRate: 1.3, splash: 1.5 },
      { cost: 120, damage: 100, range: 3.5, fireRate: 1.1, splash: 2 },
    ]
  },
  frost: {
    name: 'Frost Tower', cost: 75, damage: 8, range: 3, fireRate: 0.8,
    color: '#8bdfff', icon: '‚ùÑÔ∏è', splash: 0, slow: 0.5,
    upgrades: [
      { cost: 60, damage: 14, range: 3.3, slow: 0.6 },
      { cost: 100, damage: 22, range: 3.8, slow: 0.7 },
    ]
  },
  laser: {
    name: 'Beam Tower', cost: 150, damage: 35, range: 4, fireRate: 0.05,
    color: '#ff2d7b', icon: '‚ö°', splash: 0, slow: 0, beam: true,
    upgrades: [
      { cost: 100, damage: 50, range: 4.5 },
      { cost: 160, damage: 75, range: 5 },
    ]
  },
};

// ‚îÄ‚îÄ‚îÄ ENEMY DEFINITIONS ‚îÄ‚îÄ‚îÄ
const ENEMY_TYPES = {
  basic:  { hp: 60, speed: 1.2, reward: 10, color: '#ff4444', size: 0.3, name: 'Scout' },
  fast:   { hp: 40, speed: 2.2, reward: 15, color: '#ffaa00', size: 0.25, name: 'Runner' },
  tank:   { hp: 200, speed: 0.7, reward: 25, color: '#aa44ff', size: 0.4, name: 'Brute' },
  boss:   { hp: 800, speed: 0.5, reward: 100, color: '#ff2d7b', size: 0.5, name: 'Overlord' },
  swarm:  { hp: 25, speed: 1.8, reward: 5, color: '#44ff88', size: 0.2, name: 'Swarmer' },
};

// ‚îÄ‚îÄ‚îÄ WAVE DEFINITIONS ‚îÄ‚îÄ‚îÄ
function getWaveEnemies(w) {
  const enemies = [];
  if (w <= 3) {
    for (let i = 0; i < 5 + w * 2; i++) enemies.push('basic');
  } else if (w <= 6) {
    for (let i = 0; i < 4 + w; i++) enemies.push('basic');
    for (let i = 0; i < w - 2; i++) enemies.push('fast');
  } else if (w <= 10) {
    for (let i = 0; i < w; i++) enemies.push('basic');
    for (let i = 0; i < w - 3; i++) enemies.push('fast');
    for (let i = 0; i < Math.floor((w - 5) / 2); i++) enemies.push('tank');
  } else if (w <= 15) {
    for (let i = 0; i < w + 2; i++) enemies.push('fast');
    for (let i = 0; i < w - 5; i++) enemies.push('tank');
    for (let i = 0; i < w * 2; i++) enemies.push('swarm');
    if (w % 5 === 0) enemies.push('boss');
  } else if (w <= 20) {
    for (let i = 0; i < w - 5; i++) enemies.push('tank');
    for (let i = 0; i < w; i++) enemies.push('fast');
    for (let i = 0; i < w * 2; i++) enemies.push('swarm');
    if (w % 5 === 0) enemies.push('boss');
  } else {
    for (let i = 0; i < w - 8; i++) enemies.push('tank');
    for (let i = 0; i < w + 5; i++) enemies.push('fast');
    for (let i = 0; i < w * 3; i++) enemies.push('swarm');
    if (w % 3 === 0) enemies.push('boss');
    if (w === totalWaves) { enemies.push('boss'); enemies.push('boss'); }
  }
  return enemies;
}

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ
function resizeCanvas() {
  const wrapper = canvas.parentElement;
  canvas.width = wrapper.clientWidth;
  canvas.height = wrapper.clientHeight;
  COLS = Math.floor(canvas.width / CELL);
  ROWS = Math.floor(canvas.height / CELL);
  pathPoints = buildPath();
  rebuildPathSet();
}

resizeCanvas();
window.addEventListener('resize', () => {
  resizeCanvas();
  // Recalculate enemy pixel positions on path if needed
});

// ‚îÄ‚îÄ‚îÄ UTILITY ‚îÄ‚îÄ‚îÄ
function lerp(a, b, t) { return a + (b - a) * t; }
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
function cellCenter(gx, gy) { return [gx * CELL + CELL / 2, gy * CELL + CELL / 2]; }

function isOnPath(gx, gy) {
  // Also block cells adjacent to path for wider clearance
  return pathSet.has(`${gx},${gy}`);
}

function hasTower(gx, gy) {
  return towers.some(t => t.gx === gx && t.gy === gy);
}

// ‚îÄ‚îÄ‚îÄ DRAWING ‚îÄ‚îÄ‚îÄ
function drawGrid() {
  // Background
  ctx.fillStyle = '#0d1320';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Subtle grid
  ctx.strokeStyle = var_gridLine;
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * CELL, 0);
    ctx.lineTo(x * CELL, ROWS * CELL);
    ctx.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * CELL);
    ctx.lineTo(COLS * CELL, y * CELL);
    ctx.stroke();
  }

  // Grass texture (dots)
  for (let x = 0; x < COLS; x++) {
    for (let y = 0; y < ROWS; y++) {
      if (!pathSet.has(`${x},${y}`)) {
        const hash = (x * 7 + y * 13) % 5;
        if (hash < 2) {
          ctx.fillStyle = `rgba(0, 255, 100, ${0.02 + hash * 0.01})`;
          ctx.fillRect(x * CELL + 10 + hash * 5, y * CELL + 12 + hash * 3, 2, 2);
        }
      }
    }
  }
}

const var_gridLine = 'rgba(0, 240, 255, 0.04)';

function drawPath() {
  // Draw path cells
  pathPoints.forEach(([px, py]) => {
    if (px >= 0 && px < COLS && py >= 0 && py < ROWS) {
      ctx.fillStyle = 'rgba(40, 35, 50, 0.8)';
      ctx.fillRect(px * CELL, py * CELL, CELL, CELL);

      // Path edge glow
      ctx.fillStyle = 'rgba(100, 70, 120, 0.15)';
      ctx.fillRect(px * CELL + 1, py * CELL + 1, CELL - 2, CELL - 2);
    }
  });

  // Directional arrows on path (every few cells)
  ctx.fillStyle = 'rgba(150, 120, 180, 0.2)';
  for (let i = 0; i < pathPoints.length - 1; i += 4) {
    const [x1, y1] = pathPoints[i];
    const [x2, y2] = pathPoints[Math.min(i + 1, pathPoints.length - 1)];
    const cx = x1 * CELL + CELL / 2;
    const cy = y1 * CELL + CELL / 2;
    const angle = Math.atan2((y2 - y1), (x2 - x1));

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(6, 0);
    ctx.lineTo(-4, -5);
    ctx.lineTo(-4, 5);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Entry/Exit markers
  if (pathPoints.length > 0) {
    const [sx, sy] = cellCenter(pathPoints[0][0], pathPoints[0][1]);
    ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
    ctx.beginPath();
    ctx.arc(sx, sy, CELL * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#00ff88';
    ctx.font = '14px Orbitron';
    ctx.textAlign = 'center';
    ctx.fillText('‚ñ∂', sx, sy + 5);

    const [ex, ey] = cellCenter(pathPoints[pathPoints.length - 1][0], pathPoints[pathPoints.length - 1][1]);
    ctx.fillStyle = 'rgba(255, 45, 123, 0.3)';
    ctx.beginPath();
    ctx.arc(ex, ey, CELL * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ff2d7b';
    ctx.font = '14px Orbitron';
    ctx.fillText('‚ô¶', ex, ey + 5);
  }
}

function drawTowers() {
  towers.forEach(t => {
    const [cx, cy] = cellCenter(t.gx, t.gy);
    const def = TOWER_DEFS[t.type];

    // Range indicator on hover
    if (hoveredTower === t || (selectedTowerType === null && !sellMode)) {
      // skip
    }

    // Base
    const gradient = ctx.createRadialGradient(cx, cy, 2, cx, cy, CELL * 0.42);
    gradient.addColorStop(0, def.color);
    gradient.addColorStop(1, `${def.color}44`);
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(cx, cy, CELL * 0.38, 0, Math.PI * 2);
    ctx.fill();

    // Border
    ctx.strokeStyle = def.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, CELL * 0.38, 0, Math.PI * 2);
    ctx.stroke();

    // Level dots
    for (let i = 0; i < t.level; i++) {
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cx - 6 + i * 6, cy + CELL * 0.3, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Icon
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(def.icon, cx, cy - 1);

    // Beam effect for laser towers
    if (def.beam && t.target && t.target.hp > 0) {
      const [tx, ty] = [t.target.x, t.target.y];
      ctx.strokeStyle = `${def.color}88`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(tx, ty);
      ctx.stroke();

      ctx.strokeStyle = `${def.color}`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(tx, ty);
      ctx.stroke();
    }
  });
}

function drawEnemies() {
  enemies.forEach(e => {
    if (e.hp <= 0) return;

    const size = CELL * e.def.size;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(e.x + 2, e.y + 4, size, size * 0.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = e.def.color;
    ctx.beginPath();
    ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
    ctx.fill();

    // Frost effect
    if (e.slowTimer > 0) {
      ctx.strokeStyle = 'rgba(139, 223, 255, 0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size + 3, 0, Math.PI * 2);
      ctx.stroke();
    }

    // HP bar
    const barW = CELL * 0.7;
    const barH = 3;
    const barX = e.x - barW / 2;
    const barY = e.y - size - 6;
    const hpRatio = e.hp / e.maxHp;

    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(barX, barY, barW, barH);

    const hpColor = hpRatio > 0.6 ? '#00ff88' : hpRatio > 0.3 ? '#ffaa00' : '#ff4444';
    ctx.fillStyle = hpColor;
    ctx.fillRect(barX, barY, barW * hpRatio, barH);
  });
}

function drawProjectiles() {
  projectiles.forEach(p => {
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size || 3, 0, Math.PI * 2);
    ctx.fill();

    // Trail
    ctx.fillStyle = `${p.color}44`;
    ctx.beginPath();
    ctx.arc(p.x - p.vx * 2, p.y - p.vy * 2, 2, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function drawPlacementPreview(mx, my) {
  if (!selectedTowerType && !sellMode) return;

  const gx = Math.floor(mx / CELL);
  const gy = Math.floor(my / CELL);

  if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return;

  if (sellMode) {
    const t = towers.find(t => t.gx === gx && t.gy === gy);
    if (t) {
      const [cx, cy] = cellCenter(gx, gy);
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
      ctx.lineWidth = 2;
      ctx.strokeRect(gx * CELL + 2, gy * CELL + 2, CELL - 4, CELL - 4);
    }
    return;
  }

  const def = TOWER_DEFS[selectedTowerType];
  const canPlace = !isOnPath(gx, gy) && !hasTower(gx, gy) && gold >= def.cost;

  const [cx, cy] = cellCenter(gx, gy);

  // Range circle
  ctx.strokeStyle = canPlace ? `${def.color}44` : 'rgba(255,0,0,0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, def.range * CELL, 0, Math.PI * 2);
  ctx.stroke();

  // Cell highlight
  ctx.fillStyle = canPlace ? `${def.color}22` : 'rgba(255,0,0,0.15)';
  ctx.fillRect(gx * CELL, gy * CELL, CELL, CELL);

  ctx.strokeStyle = canPlace ? def.color : '#ff0000';
  ctx.lineWidth = 2;
  ctx.strokeRect(gx * CELL + 1, gy * CELL + 1, CELL - 2, CELL - 2);

  // Preview icon
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.globalAlpha = 0.6;
  ctx.fillText(def.icon, cx, cy);
  ctx.globalAlpha = 1;
}

// ‚îÄ‚îÄ‚îÄ HOVER TOOLTIP FOR PLACED TOWERS ‚îÄ‚îÄ‚îÄ
function showTowerTooltip(tower, x, y) {
  const tt = document.getElementById('towerTooltip');
  const def = TOWER_DEFS[tower.type];
  const stats = getCurrentStats(tower);

  tt.querySelector('.tt-name').textContent = `${def.icon} ${def.name} (Lv ${tower.level + 1})`;
  tt.querySelector('.tt-stats').innerHTML = `DMG: ${stats.damage}<br>Range: ${stats.range.toFixed(1)}<br>Sell: üí∞${Math.floor(tower.totalCost * 0.6)}`;

  const upg = def.upgrades[tower.level];
  if (upg) {
    tt.querySelector('.tt-upgrade').textContent = `‚¨Ü Upgrade: üí∞${upg.cost}`;
    tt.querySelector('.tt-upgrade').style.display = 'block';
  } else {
    tt.querySelector('.tt-upgrade').style.display = 'none';
  }

  tt.style.display = 'block';
  tt.style.left = `${x + 16}px`;
  tt.style.top = `${y - 20}px`;
}

function hideTowerTooltip() {
  document.getElementById('towerTooltip').style.display = 'none';
}

function getCurrentStats(tower) {
  const def = TOWER_DEFS[tower.type];
  let damage = def.damage, range = def.range, fireRate = def.fireRate, splash = def.splash, slow = def.slow;
  for (let i = 0; i < tower.level; i++) {
    const u = def.upgrades[i];
    if (u.damage) damage = u.damage;
    if (u.range) range = u.range;
    if (u.fireRate) fireRate = u.fireRate;
    if (u.splash) splash = u.splash;
    if (u.slow) slow = u.slow;
  }
  return { damage, range, fireRate, splash, slow };
}

// ‚îÄ‚îÄ‚îÄ ENEMY LOGIC ‚îÄ‚îÄ‚îÄ
function spawnEnemy(type) {
  const def = { ...ENEMY_TYPES[type] };
  const hpMult = 1 + (wave - 1) * 0.15;
  const [sx, sy] = cellCenter(pathPoints[0][0], pathPoints[0][1]);
  enemies.push({
    x: sx, y: sy, def, type,
    hp: Math.floor(def.hp * hpMult),
    maxHp: Math.floor(def.hp * hpMult),
    speed: def.speed,
    pathIndex: 0,
    pathProgress: 0,
    slowTimer: 0,
    alive: true,
  });
}

function updateEnemies(dt) {
  enemies.forEach(e => {
    if (e.hp <= 0 || !e.alive) return;

    let speed = e.speed;
    if (e.slowTimer > 0) {
      speed *= 0.5;
      e.slowTimer -= dt;
    }

    e.pathProgress += speed * dt * 60 / CELL;

    while (e.pathProgress >= 1 && e.pathIndex < pathPoints.length - 1) {
      e.pathProgress -= 1;
      e.pathIndex++;
    }

    if (e.pathIndex >= pathPoints.length - 1) {
      e.alive = false;
      lives--;
      updateUI();
      if (lives <= 0) endGame(false);
      return;
    }

    const [cx1, cy1] = cellCenter(pathPoints[e.pathIndex][0], pathPoints[e.pathIndex][1]);
    const ni = Math.min(e.pathIndex + 1, pathPoints.length - 1);
    const [cx2, cy2] = cellCenter(pathPoints[ni][0], pathPoints[ni][1]);

    e.x = lerp(cx1, cx2, e.pathProgress);
    e.y = lerp(cy1, cy2, e.pathProgress);
  });

  // Remove dead enemies
  enemies = enemies.filter(e => e.alive || e.hp > 0);
}

function killEnemy(e) {
  e.hp = 0;
  e.alive = false;
  gold += e.def.reward;
  score += e.def.reward;

  // Death particles
  for (let i = 0; i < 8; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 40 + Math.random() * 60;
    particles.push({
      x: e.x, y: e.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 1.5 + Math.random(),
      size: 3 + Math.random() * 3,
      color: e.def.color,
    });
  }

  updateUI();
}

// ‚îÄ‚îÄ‚îÄ TOWER LOGIC ‚îÄ‚îÄ‚îÄ
function updateTowers(dt) {
  towers.forEach(t => {
    t.cooldown -= dt;
    const stats = getCurrentStats(t);
    const [cx, cy] = cellCenter(t.gx, t.gy);
    const rangePx = stats.range * CELL;
    const def = TOWER_DEFS[t.type];

    // Find target
    let target = null;
    let bestProgress = -1;

    enemies.forEach(e => {
      if (e.hp <= 0 || !e.alive) return;
      const d = dist(cx, cy, e.x, e.y);
      if (d <= rangePx) {
        // Target furthest along path
        const progress = e.pathIndex + e.pathProgress;
        if (progress > bestProgress) {
          bestProgress = progress;
          target = e;
        }
      }
    });

    t.target = target;

    if (!target) return;

    if (def.beam) {
      // Continuous damage
      if (t.cooldown <= 0) {
        target.hp -= stats.damage * dt;
        t.cooldown = 0;
        if (target.hp <= 0) killEnemy(target);
      }
    } else if (t.cooldown <= 0) {
      t.cooldown = stats.fireRate;

      // Fire projectile
      const angle = Math.atan2(target.y - cy, target.x - cx);
      const speed = 300;
      projectiles.push({
        x: cx, y: cy,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        damage: stats.damage,
        splash: stats.splash || 0,
        slow: stats.slow || 0,
        color: def.color,
        size: stats.splash ? 5 : 3,
        target: target,
      });
    }
  });
}

function updateProjectiles(dt) {
  projectiles.forEach(p => {
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // Check hit
    enemies.forEach(e => {
      if (e.hp <= 0 || !e.alive) return;
      if (dist(p.x, p.y, e.x, e.y) < CELL * 0.4) {
        p.hit = true;

        if (p.splash > 0) {
          // Splash damage
          const splashPx = p.splash * CELL;
          enemies.forEach(e2 => {
            if (e2.hp <= 0) return;
            if (dist(p.x, p.y, e2.x, e2.y) <= splashPx) {
              e2.hp -= p.damage;
              if (p.slow > 0) e2.slowTimer = 2;
              if (e2.hp <= 0) killEnemy(e2);
            }
          });
          // Explosion particles
          for (let i = 0; i < 12; i++) {
            const angle = Math.random() * Math.PI * 2;
            const spd = 30 + Math.random() * 80;
            particles.push({
              x: p.x, y: p.y,
              vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd,
              life: 1, decay: 2 + Math.random(), size: 2 + Math.random() * 4,
              color: p.color,
            });
          }
        } else {
          e.hp -= p.damage;
          if (p.slow > 0) e.slowTimer = 2;
          if (e.hp <= 0) killEnemy(e);
        }
      }
    });

    // Out of bounds
    if (p.x < -50 || p.x > canvas.width + 50 || p.y < -50 || p.y > canvas.height + 50) {
      p.hit = true;
    }
  });

  projectiles = projectiles.filter(p => !p.hit);
}

function updateParticles(dt) {
  particles.forEach(p => {
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.life -= p.decay * dt;
    p.vx *= 0.95;
    p.vy *= 0.95;
  });
  particles = particles.filter(p => p.life > 0);
}

// ‚îÄ‚îÄ‚îÄ WAVE SPAWNING ‚îÄ‚îÄ‚îÄ
let waveQueue = [];
let spawnTimer = 0;
const SPAWN_INTERVAL = 0.6;

function startWave() {
  if (waveActive || gameOver) return;
  wave++;
  waveActive = true;
  waveQueue = getWaveEnemies(wave);
  spawnTimer = 0;

  // Shuffle a bit for variety
  for (let i = waveQueue.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [waveQueue[i], waveQueue[j]] = [waveQueue[j], waveQueue[i]];
  }

  showWaveBanner(`Wave ${wave}`);
  updateUI();
  document.getElementById('btnStart').textContent = 'In Progress...';
  document.getElementById('btnStart').style.opacity = '0.5';
}

function updateWaveSpawning(dt) {
  if (!waveActive) return;

  spawnTimer -= dt;
  if (spawnTimer <= 0 && waveQueue.length > 0) {
    spawnEnemy(waveQueue.shift());
    spawnTimer = SPAWN_INTERVAL;
  }

  // Check wave complete
  if (waveQueue.length === 0 && enemies.every(e => !e.alive || e.hp <= 0)) {
    waveActive = false;
    gold += 20 + wave * 5; // Wave bonus
    updateUI();
    document.getElementById('btnStart').textContent = 'Send Wave';
    document.getElementById('btnStart').style.opacity = '1';

    if (wave >= totalWaves) {
      endGame(true);
    }
  }
}

// ‚îÄ‚îÄ‚îÄ UI ‚îÄ‚îÄ‚îÄ
function updateUI() {
  document.getElementById('goldValue').textContent = gold;
  document.getElementById('livesValue').textContent = lives;
  document.getElementById('waveValue').textContent = `${wave} / ${totalWaves}`;
  document.getElementById('scoreValue').textContent = score;

  // Update tower card states
  Object.keys(TOWER_DEFS).forEach(type => {
    const card = document.querySelector(`.tower-card[data-tower="${type}"]`);
    if (card) {
      card.classList.toggle('disabled', gold < TOWER_DEFS[type].cost);
      card.classList.toggle('selected', selectedTowerType === type);
    }
  });

  document.getElementById('sellCard').classList.toggle('selected', sellMode);
}

function showWaveBanner(text) {
  const banner = document.getElementById('waveBanner');
  banner.textContent = text;
  banner.classList.add('show');
  setTimeout(() => banner.classList.remove('show'), 1800);
}

function endGame(won) {
  gameOver = true;
  const overlay = document.getElementById('gameOverOverlay');
  document.getElementById('gameOverTitle').textContent = won ? 'Victory!' : 'Game Over';
  document.getElementById('gameOverScore').textContent = `Score: ${score} | Waves: ${wave}/${totalWaves}`;
  overlay.classList.add('show');
}

function restartGame() {
  gold = 200; lives = 20; score = 0; wave = 0;
  waveActive = false; gameOver = false;
  selectedTowerType = null; sellMode = false;
  towers = []; enemies = []; projectiles = []; particles = [];
  waveQueue = []; speedMultiplier = 1;
  document.getElementById('gameOverOverlay').classList.remove('show');
  document.getElementById('btnStart').textContent = 'Send Wave';
  document.getElementById('btnStart').style.opacity = '1';
  document.getElementById('btnSpeed').classList.remove('active');
  resizeCanvas();
  updateUI();
}

// ‚îÄ‚îÄ‚îÄ INPUT ‚îÄ‚îÄ‚îÄ
let mouseX = 0, mouseY = 0;

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;

  // Tower hover tooltip
  const gx = Math.floor(mouseX / CELL);
  const gy = Math.floor(mouseY / CELL);
  const ht = towers.find(t => t.gx === gx && t.gy === gy);
  if (ht && !selectedTowerType && !sellMode) {
    hoveredTower = ht;
    showTowerTooltip(ht, e.clientX, e.clientY);
  } else {
    hoveredTower = null;
    hideTowerTooltip();
  }
});

canvas.addEventListener('click', (e) => {
  if (gameOver) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const gx = Math.floor(mx / CELL);
  const gy = Math.floor(my / CELL);

  if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return;

  if (sellMode) {
    const idx = towers.findIndex(t => t.gx === gx && t.gy === gy);
    if (idx >= 0) {
      const refund = Math.floor(towers[idx].totalCost * 0.6);
      gold += refund;
      towers.splice(idx, 1);
      sellMode = false;
      updateUI();
    }
    return;
  }

  // Click on existing tower to upgrade
  const existing = towers.find(t => t.gx === gx && t.gy === gy);
  if (existing && !selectedTowerType) {
    const def = TOWER_DEFS[existing.type];
    const upg = def.upgrades[existing.level];
    if (upg && gold >= upg.cost) {
      gold -= upg.cost;
      existing.totalCost += upg.cost;
      existing.level++;
      updateUI();

      // Upgrade particles
      const [cx, cy] = cellCenter(gx, gy);
      for (let i = 0; i < 6; i++) {
        const angle = Math.random() * Math.PI * 2;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(angle) * 40, vy: Math.sin(angle) * 40,
          life: 1, decay: 2, size: 3,
          color: '#ffd700',
        });
      }
    }
    return;
  }

  // Place new tower
  if (selectedTowerType) {
    const def = TOWER_DEFS[selectedTowerType];
    if (!isOnPath(gx, gy) && !hasTower(gx, gy) && gold >= def.cost) {
      gold -= def.cost;
      towers.push({
        gx, gy, type: selectedTowerType,
        level: 0, cooldown: 0, target: null,
        totalCost: def.cost,
      });

      // Place particles
      const [cx, cy] = cellCenter(gx, gy);
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(angle) * 50, vy: Math.sin(angle) * 50,
          life: 1, decay: 2, size: 3,
          color: def.color,
        });
      }

      updateUI();
    }
  }
});

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  selectedTowerType = null;
  sellMode = false;
  updateUI();
});

function selectTower(type) {
  sellMode = false;
  selectedTowerType = selectedTowerType === type ? null : type;
  updateUI();
}

function enterSellMode() {
  selectedTowerType = null;
  sellMode = !sellMode;
  updateUI();
}

function toggleSpeed() {
  speedMultiplier = speedMultiplier === 1 ? 2 : 1;
  document.getElementById('btnSpeed').classList.toggle('active', speedMultiplier === 2);
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key === '1') selectTower('archer');
  if (e.key === '2') selectTower('cannon');
  if (e.key === '3') selectTower('frost');
  if (e.key === '4') selectTower('laser');
  if (e.key.toLowerCase() === 's') enterSellMode();
  if (e.key === 'Escape') { selectedTowerType = null; sellMode = false; updateUI(); }
  if (e.key === ' ') { e.preventDefault(); startWave(); }
});

// ‚îÄ‚îÄ‚îÄ GAME LOOP ‚îÄ‚îÄ‚îÄ
let lastTime = 0;

function gameLoop(timestamp) {
  const rawDt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;
  const dt = rawDt * speedMultiplier;

  if (!gameOver) {
    updateEnemies(dt);
    updateTowers(dt);
    updateProjectiles(dt);
    updateParticles(dt);
    updateWaveSpawning(dt);
  }

  // Draw
  drawGrid();
  drawPath();
  drawTowers();
  drawEnemies();
  drawProjectiles();
  drawParticles();
  drawPlacementPreview(mouseX, mouseY);

  // Draw range for hovered tower
  if (hoveredTower) {
    const stats = getCurrentStats(hoveredTower);
    const [cx, cy] = cellCenter(hoveredTower.gx, hoveredTower.gy);
    ctx.strokeStyle = `${TOWER_DEFS[hoveredTower.type].color}33`;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.arc(cx, cy, stats.range * CELL, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  requestAnimationFrame(gameLoop);
}

// Start
updateUI();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
